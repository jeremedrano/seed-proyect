# Cursor Rules - Proyecto CRUD Usuarios con TDD

**Lo mejor de dos mundos: Clean Architecture + TDD + Seguridad + Calidad**

---

## ğŸ§ª FilosofÃ­a de Desarrollo: TDD (Test-Driven Development)

### REGLA PRINCIPAL: Siempre escribir tests ANTES del cÃ³digo

**Orden obligatorio para toda nueva funcionalidad:**

1. ğŸ”´ **RED:** Escribir el test que falla
2. ğŸŸ¢ **GREEN:** Escribir cÃ³digo mÃ­nimo para que pase
3. ğŸ”µ **REFACTOR:** Mejorar el cÃ³digo manteniendo tests verdes

### Workflow TDD por Capas (Clean Architecture):

#### Para implementar una nueva funcionalidad (ej: CreateUser):

**Paso 1: Test Domain (Entidad)**
```python
# tests/unit/domain/test_user_entity.py
@pytest.mark.unit
def test_user_creation():
    # Arrange
    user_data = {"id": 1, "email": "test@test.com", "name": "Test", "age": 25}
    
    # Act
    user = User(**user_data)
    
    # Assert
    assert user.email == "test@test.com"
    assert user.name == "Test"
```
â†’ Luego implementar `app/domain/entities/user.py`

**Paso 2: Test Application (Use Case)**
```python
# tests/unit/use_cases/test_create_user.py
@pytest.mark.unit
def test_create_user_use_case(mock_repository):
    # Arrange
    use_case = CreateUserUseCase(mock_repository)
    
    # Act
    user = use_case.execute("test@test.com", "Test", 25)
    
    # Assert
    mock_repository.save.assert_called_once()
    assert user.email == "test@test.com"
```
â†’ Luego implementar `app/application/use_cases/create_user.py`

**Paso 3: Test Infrastructure (Repository)**
```python
# tests/integration/test_user_repository.py
@pytest.mark.integration
def test_repository_saves_user(db_session):
    # Arrange
    repo = UserRepositoryImpl(db_session)
    user = User(None, "test@test.com", "Test", 25)
    
    # Act
    saved = repo.save(user)
    
    # Assert
    assert saved.id is not None
    assert saved.email == "test@test.com"
```
â†’ Luego implementar `app/infrastructure/database/repositories/user_repository_impl.py`

**Paso 4: Test Presentation (Endpoint)**
```python
# tests/e2e/test_user_endpoints.py
@pytest.mark.e2e
def test_create_user_endpoint(client):
    # Arrange
    user_data = {"email": "test@test.com", "name": "Test", "age": 25}
    
    # Act
    response = client.post("/api/v1/users/", json=user_data)
    
    # Assert
    assert response.status_code == 201
    assert response.json()["email"] == "test@test.com"
```
â†’ Luego implementar `app/presentation/api/v1/endpoints/users.py`

### PatrÃ³n AAA (Arrange-Act-Assert):

Todos los tests deben seguir este patrÃ³n para claridad y consistencia:
```python
def test_example():
    # Arrange: Preparar datos y mocks
    input_data = {"key": "value"}
    mock_service = Mock()
    
    # Act: Ejecutar funciÃ³n bajo test
    result = function_to_test(input_data, mock_service)
    
    # Assert: Verificar resultado
    assert result.status == "success"
    mock_service.save.assert_called_once()
```

---

## ğŸ—ï¸ Clean Architecture

### Reglas de Dependencia:
- âœ… Presentation â†’ Application â†’ Domain â† Infrastructure
- âŒ Domain NUNCA depende de capas externas
- âŒ Application NUNCA depende de Infrastructure o Presentation

### Estructura de archivos:
```
app/
â”œâ”€â”€ domain/           # Entidades e interfaces (sin dependencias externas)
â”‚   â”œâ”€â”€ entities/     # Modelos de negocio puros
â”‚   â”œâ”€â”€ repositories/ # Interfaces de repositorios (contratos)
â”‚   â””â”€â”€ exceptions/   # Excepciones de dominio
â”œâ”€â”€ application/      # Use Cases (casos de uso)
â”‚   â”œâ”€â”€ use_cases/    # LÃ³gica de aplicaciÃ³n
â”‚   â””â”€â”€ dto/          # Data Transfer Objects
â”œâ”€â”€ infrastructure/   # Adaptadores (DB, servicios externos)
â”‚   â”œâ”€â”€ database/     # Implementaciones de persistencia
â”‚   â”‚   â”œâ”€â”€ models/   # Modelos de ORM (SQLAlchemy)
â”‚   â”‚   â””â”€â”€ repositories/  # Implementaciones de repositorios
â”‚   â””â”€â”€ logging/      # ConfiguraciÃ³n de logging
â””â”€â”€ presentation/     # API (FastAPI endpoints)
    â”œâ”€â”€ api/          # Endpoints REST
    â”‚   â””â”€â”€ v1/       # VersiÃ³n 1 de la API
    â”œâ”€â”€ schemas/      # Pydantic schemas (request/response)
    â””â”€â”€ middleware/   # Middlewares de la API
```

### Principios de DiseÃ±o:
- **SeparaciÃ³n de responsabilidades:** Cada mÃ³dulo tiene una responsabilidad clara
- **InversiÃ³n de dependencias:** Depender de abstracciones (interfaces), no de implementaciones
- **CohesiÃ³n alta, acoplamiento bajo:** MÃ³dulos independientes y enfocados
- **DRY (Don't Repeat Yourself):** Eliminar duplicaciÃ³n de cÃ³digo

---

## ğŸ“ Convenciones de CÃ³digo

### Nomenclatura:
- **Clases:** `PascalCase` (User, UserRepository, CreateUserUseCase)
- **Funciones/mÃ©todos:** `snake_case` (process_user, get_user_by_id)
- **Constantes:** `UPPER_SNAKE_CASE` (MAX_RETRIES, DEFAULT_TIMEOUT)
- **Privados:** `_prefijo_underscore` (_parse_data, _validate_input)
- **Tests:** `test_<what_it_does>` (test_user_creation, test_save_user)

### EstÃ¡ndares de CÃ³digo:
- **Funciones:** MÃ¡ximo 50 lÃ­neas, responsabilidad Ãºnica
- **Complejidad ciclomÃ¡tica:** < 10 por funciÃ³n
- **DuplicaciÃ³n de cÃ³digo:** < 3%
- **LÃ­nea mÃ¡xima:** 100 caracteres

### Imports:
- Usar imports absolutos: `from app.domain.entities.user import User`
- No dejar imports sin usar
- Ordenar imports: stdlib â†’ third-party â†’ local

```python
# Stdlib
import os
from datetime import datetime

# Third-party
from fastapi import FastAPI, HTTPException
from sqlalchemy.orm import Session

# Local
from app.domain.entities.user import User
from app.application.use_cases.create_user import CreateUserUseCase
```

### Formato de cÃ³digo:
- No abusar de saltos de lÃ­nea (seguir ejemplo en user rules)
- Mantener anotaciones compactas pero legibles
- MÃ¡ximo 100 caracteres por lÃ­nea

### Docstrings:
```python
def create_user(email: str, name: str, age: int) -> User:
    """
    Crea un nuevo usuario en el sistema.
    
    Args:
        email: Email del usuario (debe ser vÃ¡lido)
        name: Nombre completo del usuario
        age: Edad del usuario (debe ser >= 18)
        
    Returns:
        User: Usuario creado con ID asignado
        
    Raises:
        ValueError: Si email es invÃ¡lido o age < 18
        DuplicateUserError: Si el email ya existe
        
    Example:
        >>> user = create_user("test@test.com", "Test User", 25)
        >>> print(user.id)
        1
    """
    # ImplementaciÃ³n...
```

---

## ğŸ“ PolÃ­tica de Logs

### Durante el Desarrollo:
- **Logs exhaustivos:** Agregar logs detallados en todas las etapas del desarrollo
- Incluir logs para:
  - Inicio y fin de operaciones importantes
  - Valores de variables crÃ­ticas
  - Flujos condicionales (quÃ© rama se ejecuta)
  - Operaciones de entrada/salida (archivos, BD, APIs)
  - Manejo de errores y excepciones

### DespuÃ©s de Confirmar Funcionalidad:
- Una vez confirmado que el cÃ³digo funciona correctamente
- **Preguntar al usuario** si desea eliminar o reducir logs excesivos
- Mantener Ãºnicamente logs esenciales para:
  - Errores y excepciones
  - Operaciones crÃ­ticas del negocio
  - Puntos de auditorÃ­a

### Formato de Logs:
```python
# Setup logger por mÃ³dulo
import logging
LOG = logging.getLogger(__name__)

# Uso correcto
LOG.info("Use case: CreateUser - Starting for email=%s", email)
LOG.debug("User created with ID=%d, email=%s", user.id, user.email)
LOG.warning("User not found: id=%d", user_id)
LOG.error("Error creating user: %s", str(e), exc_info=True)

# âŒ NO hacer:
print("Debug message")  # Usar LOG
LOG.info(f"User password: {password}")  # No logear info sensible
```

### Niveles de Log:
- **DEBUG:** InformaciÃ³n detallada de desarrollo (variables, flujos)
- **INFO:** Operaciones normales del sistema (inicio/fin operaciones)
- **WARNING:** Advertencias que no detienen el flujo (no encontrado, validaciÃ³n)
- **ERROR:** Errores que requieren atenciÃ³n (excepciones manejadas)
- **CRITICAL:** Errores crÃ­ticos que detienen el sistema

### Logging Seguro:
```python
# âŒ MAL - Exponer informaciÃ³n sensible
LOG.info(f"User logged in: {username} with password: {password}")
LOG.info(f"API call with key: {api_key}")

# âœ… BIEN - No logear informaciÃ³n sensible
LOG.info("User logged in: username=%s", username)
LOG.info("API call successful [key: ***%s]", api_key[-4:])  # Solo Ãºltimos 4
```

---

## ğŸ¨ Uso de Emojis

- **PERMITIDOS:** Solo en archivos `.md` (Markdown) para documentaciÃ³n
- **PROHIBIDOS:** En todos los demÃ¡s archivos:
  - CÃ³digo Python (`.py`)
  - Scripts (`.sh`, `.ps1`)
  - Archivos de configuraciÃ³n (`.json`, `.yaml`, `.yml`, `.ini`)
  - Logs y mensajes de error
  - Salidas de consola
  - Comentarios en cÃ³digo

**Nota:** Los logs, mensajes de error y cualquier salida de cÃ³digo deben usar texto plano sin emojis para mantener compatibilidad y profesionalismo.

---

## âœ… Tests

### OrganizaciÃ³n de Tests:
```
tests/
â”œâ”€â”€ unit/              # Tests sin dependencias externas (rÃ¡pidos)
â”‚   â”œâ”€â”€ domain/        # Tests de entidades
â”‚   â””â”€â”€ use_cases/     # Tests de use cases (con mocks)
â”œâ”€â”€ integration/       # Tests con DB (en memoria)
â””â”€â”€ e2e/              # Tests de endpoints (servidor completo)
```

### Markers de Pytest:

Todos los tests deben estar marcados con su tipo:
```python
@pytest.mark.unit
def test_user_entity():
    # Test unitario rÃ¡pido sin dependencias

@pytest.mark.integration
def test_user_repository(db_session):
    # Test de integraciÃ³n con BD

@pytest.mark.e2e
def test_user_endpoint(client):
    # Test end-to-end del flujo completo
```

### Comandos de Testing:

```bash
# TDD Workflow
ptw tests/unit/                          # Watch mode para TDD (desarrollo activo)

# Todos los tests
pytest tests/ -v                         # Verboso con detalles

# Por tipo (usando markers)
pytest tests/ -v -m unit                 # Solo unitarios (rÃ¡pidos - para TDD)
pytest tests/ -v -m integration          # Solo integraciÃ³n
pytest tests/ -v -m e2e                  # Solo e2e

# Por directorio
pytest tests/unit/ -v                    # Solo unitarios (rÃ¡pidos)
pytest tests/integration/ -v             # Solo integraciÃ³n
pytest tests/e2e/ -v                     # Solo e2e

# Con cobertura
pytest tests/ --cov=app                  # Cobertura bÃ¡sica
pytest tests/ --cov=app --cov-report=html  # Reporte HTML
pytest tests/ --cov=app --cov-report=term-missing  # Ver lÃ­neas no cubiertas
pytest tests/ --cov=app --cov-fail-under=80  # Fallar si < 80%

# Tests especÃ­ficos
pytest tests/ -k "test_create_user"      # Tests que contengan "create_user"
pytest tests/unit/test_user_entity.py::test_user_creation  # Test especÃ­fico

# Modo debug
pytest tests/ -v -s                      # Con print statements
pytest tests/ -v --pdb                   # Debugger on failure
```

### Cobertura mÃ­nima:
- **Global:** â‰¥ 80% (obligatorio)
- **Domain:** â‰¥ 90% (entidades puras, crÃ­ticas)
- **Application:** â‰¥ 90% (lÃ³gica de negocio)
- **Infrastructure:** â‰¥ 70% (integraciones)
- **Presentation:** â‰¥ 80% (endpoints)

### Tipos de Tests Requeridos:
- **Unit Tests:** Para funciones y mÃ©todos individuales (>90% coverage)
- **Integration Tests:** Para interacciones con servicios externos (DB, APIs)
- **E2E Tests:** Happy paths de flujos principales
- **Edge Cases:** Validar casos lÃ­mite y errores

---

## ğŸ”’ PolÃ­tica de Seguridad

### Seguridad por DiseÃ±o (Security by Design)

- **Principio obligatorio:** Toda funcionalidad debe considerar seguridad desde el diseÃ±o
- Aplicar principios de:
  - **Defensa en profundidad:** MÃºltiples capas de seguridad
  - **MÃ­nimo privilegio:** Acceso mÃ­nimo necesario
  - **Fail-safe defaults:** ConfiguraciÃ³n segura por defecto
  - **ValidaciÃ³n de entrada:** Nunca confiar en datos externos

### ProtecciÃ³n de InformaciÃ³n Sensible

#### NUNCA commitear:
- âŒ ContraseÃ±as, API keys, tokens
- âŒ Credenciales de bases de datos
- âŒ Certificados y claves privadas
- âŒ InformaciÃ³n personal identificable (PII)

#### Usar variables de entorno:
```python
# âŒ MAL - Hardcoded credentials
DB_PASSWORD = "mi_password_123"
API_KEY = "sk_live_abc123"

# âœ… BIEN - Variables de entorno
import os

DB_PASSWORD = os.getenv('DB_PASSWORD')
API_KEY = os.getenv('API_KEY')

if not DB_PASSWORD:
    raise ValueError("DB_PASSWORD environment variable not set")
```

#### Archivos a proteger:
- `.env` debe estar en `.gitignore`
- Archivos de configuraciÃ³n con secretos
- Logs con informaciÃ³n sensible
- Base de datos de desarrollo (`*.db`)

### Vulnerabilidades Comunes a Evitar

#### 1. InyecciÃ³n SQL
```python
# âŒ MAL - Vulnerable a SQL injection
query = f"SELECT * FROM users WHERE email = '{email}'"

# âœ… BIEN - Usar ORM (SQLAlchemy) con parÃ¡metros
user = session.query(User).filter(User.email == email).first()
```

#### 2. ValidaciÃ³n de Entrada
```python
# âœ… BIEN - Validar con Pydantic
from pydantic import BaseModel, EmailStr, Field

class UserCreate(BaseModel):
    email: EmailStr
    name: str = Field(..., min_length=1, max_length=100)
    age: int = Field(..., ge=18, le=120)

# âœ… BIEN - Validar en domain
def create_user(email: str, name: str, age: int) -> User:
    if not email or '@' not in email:
        raise ValueError("Invalid email format")
    if age < 18:
        raise ValueError("Age must be >= 18")
    # ...
```

#### 3. Manejo Seguro de Errores
```python
# âŒ MAL - Exponer detalles internos
@app.post("/users/")
def create_user(user: UserCreate):
    try:
        return service.create_user(user)
    except Exception as e:
        return {"error": str(e)}  # Puede exponer stack trace

# âœ… BIEN - Mensaje genÃ©rico al usuario, detalles en logs
@app.post("/users/")
def create_user(user: UserCreate):
    try:
        return service.create_user(user)
    except ValueError as e:
        LOG.warning("User validation failed: %s", e)
        raise HTTPException(status_code=400, detail="Invalid user data")
    except Exception as e:
        LOG.error("Error creating user: %s", e, exc_info=True)
        raise HTTPException(status_code=500, detail="Internal server error")
```

### Escaneo de Vulnerabilidades

#### Herramientas obligatorias:
```bash
# Python - Escaneo de dependencias
pip-audit                                # Vulnerabilidades en dependencias
safety check                             # Vulnerabilidades conocidas

# AnÃ¡lisis estÃ¡tico de seguridad
bandit -r app/                           # Security linting

# Escaneo de secretos (antes de commit)
git secrets --scan                       # Secretos en commits
```

---

## ğŸ¯ PolÃ­tica de Calidad de CÃ³digo

### AuditorÃ­a de Calidad

- **Obligatorio:** Auditar la calidad del cÃ³digo antes de commits
- Programar siempre con el objetivo de cumplir las reglas auditadas
- Mantener estÃ¡ndares de calidad consistentes en todo el proyecto

### Herramientas de AnÃ¡lisis de Calidad

```bash
# Python - AnÃ¡lisis estÃ¡tico
pylint app/ --fail-under=8.0             # Lint check
flake8 app/ --max-line-length=100        # Style check
mypy app/ --strict                       # Type checking

# Formateo de cÃ³digo
black app/ --check                       # Check format
black app/                               # Auto-format
isort app/ --check-only                  # Check imports order
isort app/                               # Sort imports

# Complejidad y mantenibilidad
radon cc app/ -a -nb                     # Complejidad ciclomÃ¡tica
radon mi app/ -nb                        # Ãndice de mantenibilidad
```

### MÃ©tricas de Calidad:
- **Complejidad ciclomÃ¡tica:** < 10 por funciÃ³n
- **DuplicaciÃ³n de cÃ³digo:** < 3%
- **Cobertura de tests:** â‰¥ 80%
- **Pylint score:** â‰¥ 8.0/10
- **Funciones:** â‰¤ 50 lÃ­neas
- **LÃ­neas por archivo:** â‰¤ 500 (ideal), â‰¤ 1000 (mÃ¡ximo)

### Comentarios:
```python
# âŒ MAL - Comentario obvio
# Incrementar contador en 1
counter += 1

# âœ… BIEN - Explicar decisiÃ³n no obvia
# Usamos Session.merge() en lugar de add() porque el objeto
# puede venir de otra sesiÃ³n y causarÃ­a DetachedInstanceError
session.merge(user)
```

---

## ğŸš« Prohibiciones

### NO hacer:
- âŒ Implementar cÃ³digo sin test previo (TDD obligatorio)
- âŒ Commitear cÃ³digo con tests fallando
- âŒ Domain con dependencias a frameworks (FastAPI, SQLAlchemy, etc.)
- âŒ LÃ³gica de negocio en controllers (presentation)
- âŒ Funciones >50 lÃ­neas sin refactorizar
- âŒ Complejidad ciclomÃ¡tica >10
- âŒ Dejar imports sin usar
- âŒ Usar `print()` (usar logging)
- âŒ Hardcodear valores sensibles (usar config o env vars)
- âŒ Hacer queries SQL directos (usar ORM)
- âŒ Usar `except: pass` sin logging
- âŒ Exponer informaciÃ³n sensible en logs
- âŒ Ignorar warnings de linters
- âŒ Duplicar cÃ³digo (usar funciones/clases)
- âŒ Tests sin markers (@pytest.mark.unit/integration/e2e)

### Siempre hacer:
- âœ… Test primero (TDD: Red â†’ Green â†’ Refactor)
- âœ… PatrÃ³n AAA en tests (Arrange-Act-Assert)
- âœ… Nombres descriptivos y claros
- âœ… CÃ³digo simple y legible (KISS)
- âœ… Refactorizar con tests verdes
- âœ… Logging en operaciones importantes
- âœ… Validar entradas externas
- âœ… Documentar con docstrings
- âœ… Revisar cÃ³digo con linters
- âœ… Mantener coverage â‰¥ 80%
- âœ… Marcar tests con @pytest.mark.*

---

## ğŸ“‹ Checklist Pre-Commit

### Durante ImplementaciÃ³n:
- [ ] Â¿EscribÃ­ el test primero? (ğŸ”´ RED)
- [ ] Â¿El test falla por la razÃ³n correcta?
- [ ] Â¿EscribÃ­ el cÃ³digo mÃ­nimo para pasar? (ğŸŸ¢ GREEN)
- [ ] Â¿Todos los tests pasan?
- [ ] Â¿RefactoricÃ© mejorando el diseÃ±o? (ğŸ”µ REFACTOR)
- [ ] Â¿Los tests siguen patrÃ³n AAA (Arrange-Act-Assert)?
- [ ] Â¿Los tests tienen markers (@pytest.mark.unit/integration/e2e)?

### Calidad de CÃ³digo:
- [ ] Â¿La cobertura se mantiene â‰¥ 80%?
- [ ] Â¿Las funciones tienen â‰¤ 50 lÃ­neas?
- [ ] Â¿La complejidad ciclomÃ¡tica es < 10?
- [ ] Â¿El cÃ³digo sigue Clean Architecture?
- [ ] Â¿No hay duplicaciÃ³n excesiva de cÃ³digo?
- [ ] Â¿AgreguÃ© logging apropiado?
- [ ] Â¿DocumentÃ© con docstrings?
- [ ] Â¿No dejÃ© imports sin usar?
- [ ] Â¿Nomenclatura clara y consistente?

### Seguridad:
- [ ] Â¿ValidÃ© todas las entradas externas?
- [ ] Â¿No expuse informaciÃ³n sensible en logs?
- [ ] Â¿No hay credenciales hardcodeadas?
- [ ] Â¿Manejo seguro de errores (no exponer detalles internos)?

### Antes de Hacer Commit:
```bash
# Ejecutar este bloque de comandos
pytest tests/ -v                         # Todos los tests pasan
pytest tests/ --cov=app --cov-fail-under=80  # Coverage â‰¥ 80%
pylint app/ --fail-under=8.0            # Pylint â‰¥ 8.0
flake8 app/ --max-line-length=100       # Sin errores de estilo
black app/ --check                       # CÃ³digo formateado
isort app/ --check-only                 # Imports ordenados
pip-audit                                # Sin vulnerabilidades
bandit -r app/                           # Sin issues de seguridad
```

---

## ğŸ“š DocumentaciÃ³n del Proyecto

### Estructura de DocumentaciÃ³n:

```
docs/
â”œâ”€â”€ changelog/          # Historial oficial del proyecto (SE SUBE A GIT)
â”‚   â”œâ”€â”€ README.md
â”‚   â””â”€â”€ YYYY-MM-DD_fase-N_descripcion.md
â”‚
â””â”€â”€ changelog-ia/       # BitÃ¡cora privada de IA (NO SE SUBE - ignorado en git)
    â”œâ”€â”€ README.md
    â””â”€â”€ changelog-YYYY-MM-DD-HH-MM.md
```

### docs/changelog/ - DocumentaciÃ³n Oficial (SE SUBE A GIT)

**PropÃ³sito:** Historial oficial de desarrollo del proyecto.

**Formato de archivos:**
```
docs/changelog/
â”œâ”€â”€ YYYY-MM-DD_fase-N_descripcion-corta.md
â””â”€â”€ YYYY-MM-DD_feature-nombre.md
```

**Contenido requerido:**
```markdown
# Changelog - [TÃ­tulo de la Fase/Feature]

**Fecha:** YYYY-MM-DD
**Fase:** N - Nombre de la Fase
**Estado:** âœ… COMPLETADA / ğŸš§ EN PROGRESO / âŒ FALLIDA

## ğŸ¯ Objetivo
[QuÃ© se querÃ­a lograr]

## âœ… Cambios Realizados
[QuÃ© se hizo especÃ­ficamente - archivos, funciones, clases]

## ğŸ“š Aprendizajes
[QuÃ© se aprendiÃ³ durante el desarrollo]

## ğŸš§ Problemas Encontrados y Soluciones
[ObstÃ¡culos y cÃ³mo se resolvieron]

## ğŸ“ Mejoras Sugeridas
[QuÃ© se podrÃ­a mejorar en el futuro]

## ğŸš€ PrÃ³ximos Pasos
[QuÃ© sigue despuÃ©s de esto]
```

### docs/changelog-ia/ - BitÃ¡cora Privada (NO SE SUBE)

**PropÃ³sito:** Proveer contexto detallado para entrenamiento de la IA.

**Obligatorio:** La IA DEBE leer estos changelogs antes de cualquier desarrollo.

**NO VERSIONADO:** Este directorio NO debe subirse a Git (estÃ¡ en .gitignore).

**Formato de archivos:**
```
docs/changelog-ia/
â””â”€â”€ changelog-YYYY-MM-DD-HH-MM.md
```

**Contenido requerido:**
```markdown
# Changelog IA - YYYY-MM-DD HH:MM

## Contexto
- SituaciÃ³n inicial del proyecto
- Problema a resolver
- Objetivo del cambio

## Cambios Realizados

### Archivos Modificados
- `app/domain/entities/user.py`: Agregada validaciÃ³n de email en lÃ­nea 25
- `app/application/use_cases/create_user.py`: Refactorizada lÃ³gica de validaciÃ³n

### Funciones/Clases AÃ±adidas
- `validate_email(email: str) -> bool`: Valida formato de email
- `UserValidator`: Clase para validaciones de usuario

### Funciones/Clases Modificadas
- `CreateUserUseCase.execute()`: Ahora usa UserValidator, reducida complejidad de 12 a 6

### Funciones/Clases Eliminadas
- `_validate_email_format()`: Consolidada en UserValidator

## Tests AÃ±adidos
- `tests/unit/test_user_validator.py`: 10 tests, coverage 100%
- `tests/integration/test_create_user_integration.py`: 5 tests

## Dependencias
- Agregado: `pydantic==2.5.0`
- Actualizado: `fastapi==0.104.1` (de 0.103.0)

## Comandos Ejecutados
```bash
pytest tests/ -v
pytest tests/ --cov=app --cov-report=html
pylint app/ --fail-under=8.0
```

## Resultados de AuditorÃ­as

### Seguridad
- pip-audit: 0 vulnerabilidades
- bandit: 0 issues crÃ­ticos

### Calidad
- pylint: 8.7/10 (mejorado de 7.8)
- complejidad ciclomÃ¡tica: max 8 (reducido de 12)
- coverage: 85% (incrementado de 78%)

## Errores Encontrados y Soluciones
- **Error:** ValidationError al crear usuario sin email
  - **SoluciÃ³n:** Agregada validaciÃ³n en UserValidator antes de llamar al repositorio

## Notas TÃ©cnicas
- Implementado patrÃ³n Strategy para validaciones
- Considerada performance: validaciones en O(1)
- RefactorizaciÃ³n redujo duplicaciÃ³n de 5% a 1%

## Decisiones de DiseÃ±o
- **DecisiÃ³n:** Usar UserValidator en lugar de validaciÃ³n inline
  - **RazÃ³n:** Reducir duplicaciÃ³n y facilitar testing
  - **Trade-off:** Ligera sobrecarga de abstracciÃ³n vs mantenibilidad
```

### CuÃ¡ndo Crear Changelog:

**Oficial (docs/changelog/):**
- âœ… Al completar cada fase del plan
- âœ… Al implementar una feature importante
- âœ… Al resolver un problema complejo que otros deben conocer
- âœ… Antes de commits importantes
- âœ… Cuando hay decisiones tÃ©cnicas que impactan el proyecto

**IA (docs/changelog-ia/):**
- âœ… DespuÃ©s de cada desarrollo significativo
- âœ… Cuando se ejecutan auditorÃ­as de seguridad/calidad
- âœ… Al refactorizar cÃ³digo existente
- âœ… Cuando se encuentran y resuelven bugs
- âœ… Para proveer contexto para futuras sesiones con IA

### Reglas de DocumentaciÃ³n:
1. **Obligatorio:** Crear changelog en AMBOS directorios despuÃ©s de cada desarrollo significativo
2. **Lectura obligatoria:** La IA DEBE leer changelogs de `docs/changelog-ia/` al iniciar tareas
3. **Nomenclatura:**
   - Oficial: `YYYY-MM-DD_fase-N_descripcion.md`
   - IA: `changelog-YYYY-MM-DD-HH-MM.md`
4. **Momento:** Crear changelogs DESPUÃ‰S de confirmar funcionalidad
5. **Detalle:** Changelog-IA exhaustivo; changelog-oficial ejecutivo
6. **Versionado:**
   - `docs/changelog-ia/` â†’ NO versionado (local del desarrollador)
   - `docs/changelog/` â†’ SÃ versionado (compartido con equipo)

---

## ğŸ› ï¸ ConfiguraciÃ³n de Herramientas

### pytest.ini (Ya configurado):
```ini
[pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = 
    -v
    --strict-markers
    --tb=short
markers =
    unit: Unit tests (fast, no external dependencies)
    integration: Integration tests (with database)
    e2e: End-to-end tests (full API flow)
```

### .pylintrc (Recomendado crear):
```ini
[MASTER]
fail-under=8.0

[FORMAT]
max-line-length=100

[MESSAGES CONTROL]
disable=
    missing-module-docstring,
    too-few-public-methods

[DESIGN]
max-args=5
max-locals=15
max-branches=12
max-statements=50
```

### .flake8 (Recomendado crear):
```ini
[flake8]
max-line-length = 100
exclude = .git,__pycache__,venv,.venv,__init__.py
ignore = E203, W503
```

### pyproject.toml (Recomendado crear - Black & isort):
```toml
[tool.black]
line-length = 100
target-version = ['py39']
exclude = '''
/(
    \.git
  | __pycache__
  | venv
  | \.venv
)/
'''

[tool.isort]
profile = "black"
line_length = 100
skip = [".venv", "venv", "__pycache__"]
```

### requirements-dev.txt (Recomendado crear):
```txt
# Testing
pytest>=7.4
pytest-cov>=4.1
pytest-mock>=3.12
pytest-watch>=4.2

# Code Quality
pylint>=3.0
flake8>=6.1
mypy>=1.7
black>=23.12
isort>=5.12
radon>=6.0

# Security
pip-audit>=2.6
bandit>=1.7
```

---

## ğŸ“š Comandos RÃ¡pidos

### TDD Workflow:
```bash
# Watch mode para desarrollo activo
ptw tests/unit/

# Ejecutar tests especÃ­ficos mientras desarrollas
pytest tests/unit/test_create_user_use_case.py -v
```

### Testing Completo:
```bash
# Todos los tests
pytest tests/ -v

# Por tipo (usando markers)
pytest tests/ -v -m unit                 # Solo unitarios
pytest tests/ -v -m integration          # Solo integraciÃ³n
pytest tests/ -v -m e2e                  # Solo e2e

# Con cobertura
pytest tests/ --cov=app --cov-report=html
pytest tests/ --cov=app --cov-report=term-missing
pytest tests/ --cov=app --cov-fail-under=80

# Tests especÃ­ficos
pytest tests/ -k "test_create_user"
pytest tests/unit/test_user_entity.py::test_user_creation
```

### Calidad de CÃ³digo:
```bash
# Lint y formato
pylint app/ --fail-under=8.0
flake8 app/ --max-line-length=100
black app/ --check
isort app/ --check-only

# Auto-format
black app/
isort app/

# Complejidad
radon cc app/ -a -nb
radon mi app/ -nb
```

### Seguridad:
```bash
# Escaneo de vulnerabilidades
pip-audit
bandit -r app/
```

### Pre-Commit Completo:
```bash
# Ejecutar todo antes de commit
pytest tests/ -v && \
pytest tests/ --cov=app --cov-fail-under=80 && \
pylint app/ --fail-under=8.0 && \
flake8 app/ --max-line-length=100 && \
black app/ --check && \
isort app/ --check-only && \
pip-audit && \
bandit -r app/
```

---

## ğŸ¯ Objetivo del Proyecto

**PoC:** CRUD de usuarios sin autenticaciÃ³n, con Clean Architecture y TDD estricto.

**CaracterÃ­sticas:**
- FastAPI como framework web
- SQLAlchemy como ORM
- SQLite como base de datos (desarrollo)
- Pytest para testing
- Clean Architecture con separaciÃ³n de capas
- TDD como metodologÃ­a de desarrollo

**Futuro:** Agregar autenticaciÃ³n JWT, autorizaciÃ³n, compliance, y otras features sin tocar cÃ³digo existente (gracias a Clean Architecture).

**Principios:**
- TDD estricto para nueva funcionalidad
- Cobertura de tests â‰¥ 80%
- Seguridad por diseÃ±o
- CÃ³digo limpio y mantenible (pylint â‰¥ 8.0, complejidad < 10)
- DocumentaciÃ³n exhaustiva

---

## ğŸ“– Referencias

- [Clean Architecture (Uncle Bob)](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)
- [TDD by Example (Kent Beck)](https://www.amazon.com/Test-Driven-Development-Kent-Beck/dp/0321146530)
- [Clean Code (Robert C. Martin)](https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882)
- [FastAPI Documentation](https://fastapi.tiangolo.com/)
- [FastAPI Testing](https://fastapi.tiangolo.com/tutorial/testing/)
- [Pytest Documentation](https://docs.pytest.org/)
- [Python Security Best Practices](https://python.readthedocs.io/en/stable/library/security_warnings.html)
- [PEP 8 - Style Guide](https://peps.python.org/pep-0008/)
- [SQLAlchemy Documentation](https://docs.sqlalchemy.org/)
